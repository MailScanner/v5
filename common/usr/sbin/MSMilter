#!/usr/bin/perl -U -I /usr/share/MailScanner/perl

# (c) 2018 MailScanner Project <https://www.mailscanner.info>
#          Version 1.0
#
#     This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#    Contributed by Shawn Iverson for MailScanner <shawniverson@efa-project.org>

use strict 'vars';
no strict 'refs';
no strict 'subs';
use POSIX;
require 5.005;

use DirHandle;
use File::Basename;
use File::Copy;
use IO::File;
use IO::Pipe;
use Sendmail::PMilter;
use Socket;
use POSIX qw(strftime);
use Sys::Hostname;
use Time::HiRes qw( gettimeofday );

use MailScanner::Lock;
use MailScanner::Log;
use MailScanner::Config;
use MailScanner::CustomConfig;
use MailScanner::Message;

my $ConfFile;

sub smtp_id {
  my $type = MailScanner::Config::QuickPeek($ConfFile, 'msmailqueuetype');
  if ($type =~ /long/i) {
        # Long queue IDs
        my $seconds=0;
        my $microseconds=0;
        use Time::HiRes qw( gettimeofday );
        ($seconds, $microseconds) = gettimeofday;
        my $microseconds_orig=$microseconds;
        my @BASE52_CHARACTERS = ("0","1","2","3","4","5","6","7","8","9",
                                "B","C","D","F","G","H","J","K","L","M",
                                "N","P","Q","R","S","T","V","W","X","Y",
                                "Z","b","c","d","f","g","h","j","k","l",
                                "m","n","p","q","r","s","t","v","w","x","y","z");
        my $encoded='';
        my $file_out;
        my $count=0;
        while ($count < 6) {
                $encoded.=$BASE52_CHARACTERS[$seconds%52];
                $seconds/=52;
                $count++;
        }
        $file_out=reverse $encoded;
        $encoded='';
        $count=0;
        while ($count < 4) {
                $encoded.=$BASE52_CHARACTERS[$microseconds%52];
                $microseconds/=52;
                $count++;
        }
        $file_out.=reverse $encoded;

        # We check the generated ID...
        if ($file_out !~ /[A-Za-z0-9]{12,20}/) {
                # Something has gone wrong, back to short ID for safety
                MailScanner::Log::WarnLog("Milter:  ERROR generating long queue ID");
                $file_out = sprintf("%05X%lX", int(rand 1000000)+1, int(rand 1000000)+1);
        }
     return $file_out;
  } else {
      # No file to stat, so just randomly generate
      return sprintf("%05X%lX", int(rand 1000000)+1, int(rand 1000000)+1);
  }
}

sub connect_callback
{
        my $ctx = shift;
        my $hostname = shift;
        my $sockaddr_in = shift;
        my ($port, $iaddr);
        my $ip;
        my $message_ref = $ctx->getpriv();

        my $message = $hostname;

        if (defined $sockaddr_in)
        {
            ($port, $iaddr) = sockaddr_in($sockaddr_in);
            $ip = inet_ntoa($iaddr);
            $message .= ' [' . $ip . ']';
        }

        # Localhost relaying email?  Accept the message for delivery
        if ($ip =~ /^127/ || $ip =~ /^::1$/) {
            return Sendmail::PMilter::SMFIS_ACCEPT;
        }
        
        ${$message_ref} = $message;
      
        $ctx->setpriv($message_ref);

        Sendmail::PMilter::SMFIS_CONTINUE;
}

sub helo_callback
{
        my $ctx = shift;
        my $helohost = shift;
        my $message_ref = $ctx->getpriv();
        my $message = "Received: from $helohost";
        # Watch for the second callback
        if ( $message ne substr(${$message_ref}, 0, length($message)) ) {
            ${$message_ref} = $message . ' (' . ${$message_ref} . ')' ."\n";
        }

        $ctx->setpriv($message_ref);

        Sendmail::PMilter::SMFIS_CONTINUE;
}

sub envrcpt_callback
{
        my $ctx = shift;
        my @args = @_;
        my $id = smtp_id;
        my $message_ref = $ctx->getpriv();
        my $datestring = strftime "%a, %e %b %Y %T %z (%Z)", localtime;
        my $symbols = $ctx->{symbols};
  
        # Todo?
        # display ssl certs if client provided them maybe...
        if (defined($symbols->{'H'}) && defined($symbols->{'H'}->{'{tls_version}'}) && defined($symbols->{'H'}->{'{cipher}'}) && defined($symbols->{'H'}->{'{cipher_bits}'})) {
            ${$message_ref} .= '        (using ' . $symbols->{'H'}->{'{tls_version}'} . ' with cipher ' . $symbols->{'H'}->{'{cipher}'} . ' (' . $symbols->{'H'}->{'{cipher_bits}'} . '/' . $symbols->{'H'}->{'{cipher_bits}'} . ' bits))' . "\n";
        }
        if (!defined($symbols->{'H'}->{'{cert_subject}'})) {
            ${$message_ref} .= '        (no client certificate requested)' . "\n";
        }
        ${$message_ref} .= '        by ' . hostname . ' (MailScanner Milter) with SMTP id ' . $id . "\n" . '        for ' . join(', ', @args) . '; ' . $datestring . "\n";

        $ctx->setpriv($message_ref);

        Sendmail::PMilter::SMFIS_CONTINUE;
}

sub header_callback
{
        my $ctx = shift;
        my $headerf = shift;
        my $headerv = shift;
        my $message_ref = $ctx->getpriv();

        ${$message_ref} .= $headerf . ': ' . $headerv . "\n";
        $ctx->setpriv($message_ref);

        Sendmail::PMilter::SMFIS_CONTINUE;
}

sub eoh_callback
{
        my $ctx = shift;
        my $message_ref = $ctx->getpriv();

        # Signal the end of the header here
        ${$message_ref} .= "\n";

        $ctx->setpriv($message_ref);

        Sendmail::PMilter::SMFIS_CONTINUE;
}

sub body_callback
{
        my $ctx = shift;
        my $body_chunk = shift;
        my $len = shift;
        my $message_ref = $ctx->getpriv();

        ${$message_ref} .= $body_chunk;

        $ctx->setpriv($message_ref);

        Sendmail::PMilter::SMFIS_CONTINUE;
}

sub eom_callback
{
        my $ctx = shift;
        my $message_ref = $ctx->getpriv();
        my $id ='';
        my $buffer='';
        my $to='';
        my $ip='';

        # Are we in scanner mode?
        my $scannermode = MailScanner::Config::QuickPeek($ConfFile, 'milterscanner');

        # Extract id, envelope to, ip from message efficiently
        while (${$message_ref} =~ /([^\n]+)\n?/g) {
            my $line = $1;
            $buffer .= $1 . "\n";
            if ($line =~ /^Received: / ) {
                $ip = '127.0.0.1';
                if ($line =~ /^Received: .+?\(.*?\[(?:IPv6:)?([0-9a-f.:]+)\]/i) {
                    $ip = $1;
                }
            } elsif ( $line =~ m/^.*SMTP id / ) {
                $line =~ s/^.*SMTP id //;
                $id = $line;
            } elsif ( $line =~ /^\s+for / ) {
                $line =~ s/^\s+for //;
                $line =~ s/^\<//;
                $line =~ s/\>.*$//;
                $to = $line;
                last;
            }
        }

        my $mailfrom='';
        my $symbols = $ctx->{symbols};
        # Capture the Mail From address for further processing
        # We'll create a Header to store the Mail From attribute for MailScanner
        if (defined($symbols->{'M'}) && defined($symbols->{'M'}->{'{mail_addr}'})) {
            $mailfrom=$symbols->{'M'}->{'{mail_addr}'};
            # Null Sender 
            # RFC 1123, 821
            if ($mailfrom eq '') {
                $mailfrom='<>';
            }
        } else {
             # Null Sender 
             # RFC 1123, 821
             $mailfrom='<>';
        }

        # Ok we have sufficient info to start writing to disk
        my $queuehandle = new FileHandle;
        # Cannot access config values inside of this callback, use ms-peek
        my $incoming = MailScanner::Config::QuickPeek($ConfFile,'incomingqueuedir');
        $incoming =~ s/\n//;
        if ($incoming eq '') {
            MailScanner::Log::WarnLog("Milter:  Unable to determine incoming queue!");
            Sendmail::PMilter::SMFIS_TEMPFAIL;
            return;
        }
        my $file = "$incoming/$id";

        my $ret;
        $ret = MailScanner::Lock::openlock($queuehandle,'>' . $file, 'w');
        if ($ret != 1) {
            MailScanner::Log::WarnLog("Milter:  Unable to to open queue file for writing!");
            Sendmail::PMilter::SMFIS_TEMPFAIL;
            return;
        }
        # Inject a Mail From Header
        my $org = MailScanner::Config::DoPercentVars('%org-name%');
        $org =~ s/\n//;
        # Write out to disk

        # Advance to end of first Received: Header
        my $test;
        my $buffer2;
        while (${$message_ref} =~ /(.*)\n?/g) {
            $test = $1;
            if ( $test =~ /^\s/ ) {
                # Still in a header continuation
                $buffer .= $test . "\n";
                next;
            } else {
                # End of first Received Header
                $buffer2 = $test . "\n";
                last;
            }
        }
        # Write out first received header
        $queuehandle->print($buffer);

        # Add Mail From to Header
        $queuehandle->print('X-' . $org . '-MailScanner-Milter-Mail-From: ' . $mailfrom . "\n");

        # Write beginning of second received header
        $queuehandle->print($buffer2);

        # Add header info up to this point
        while (${$message_ref} =~ /(.*)\n?/g) {
           my $line = $1;
           $queuehandle->print($line . "\n");
        }

        $queuehandle->flush();
        MailScanner::Lock::unlockclose($queuehandle);

        $ctx->setpriv(undef);

        # Determine what to do next
        if ($scannermode =~ /^yes$/) {
           # Blacklist test
           # Build a message object to test against
           my $message = {};
           if ($mailfrom ne '<>') {
               $message->{from} = $mailfrom;
           } else {
               $message->{from} = '';
           }
           push @{$message->{to}}, $to;
           $message->{clientip} = $ip;
           my $user;
           my $domain;
           ($user, $domain) = MailScanner::Message::address2userdomain($message->{from});
           $message->{fromuser} = $user;
           $message->{fromdomain} = $domain;

           my $touser;
           my $todomain;
        
           ($touser, $todomain) = MailScanner::Message::address2userdomain(@{$message->{to}}[0]);
           push @{$message->{touser}}, $touser;
           push @{$message->{todomain}}, $todomain;
          
           my $test;
           # Check whitelist first
           $test = MailScanner::Config::Value('spamwhitelist', $message);

           # Not in whitelist, then check blacklist
           if ($test == 0) {
               # test
               $test = MailScanner::Config::Value('spamblacklist', $message);

               # Blacklisted, fire a reject
               if ($test == 1) {
                   # Set reject code
                   $ctx->setreply('554', '5.7.1', 'Message Blacklisted');
                  return Sendmail::PMilter::SMFIS_REJECT;
               }
           }
        }

        # Send DISCARD signal to accept message and drop from postfix
        # for mailscanner processing
        Sendmail::PMilter::SMFIS_DISCARD;
}

#
# Create and write a PID file for a given process id
#
sub WritePIDFile {
  my($process,$PidFile) = @_;

  my $pidfh = new FileHandle;
  $pidfh->open(">$PidFile")
    or MailScanner::Log::WarnLog("Cannot write pid file %s, %s", $PidFile, $!);
  print $pidfh "$process\n";
  $pidfh->close();
}

#
# Start logging
#
sub StartLogging {
  my($filename) = @_;

  my $procname = 'MSMilter';

  my $logbanner = "MSMilter Daemon starting...";

  MailScanner::Log::Configure($logbanner, 'syslog'); 

  # Need to know log facility *before* we have read the whole config file!
  my $facility = MailScanner::Config::QuickPeek($filename, 'syslogfacility');
  my $logsock  = MailScanner::Config::QuickPeek($filename, 'syslogsockettype');

  MailScanner::Log::Start($procname, $facility, $logsock);
}

BEGIN {
    chdir('/usr/share/MailScanner/perl');

    $ENV{PATH}="/sbin:/bin:/usr/sbin:/usr/bin";
   
    umask 0077;
    
    $ConfFile = $ARGV[0];
    # Use the default if we couldn't find theirs. Will save a lot of grief.
    $ConfFile = '/etc/MailScanner/MailScanner.conf' if $ConfFile eq "" ||
                                                           !(-f $ConfFile);
     
    # Start logging
    StartLogging($ConfFile);
   
    MailScanner::Config::initialise(MailScanner::Config::QuickPeek($ConfFile,
                                  'customfunctionsdir'));
    # Read Config File
    MailScanner::Config::Read($ConfFile);

    my $pid = fork;
    
    if (!defined($pid)) {
        MailScanner::Log::WarnLog("Milter:  Unable to fork!");
        exit 1;
    }
    if ($pid == 0) {
        $0 = "MSMilter Daemon";

        # Need this new parent process to ignore SIGHUP, and catch SIGTERM
        $SIG{'HUP'} = 'IGNORE';
        $SIG{'TERM'} = \&ExitParent;
    
        my $PidFile = MailScanner::Config::QuickPeek($ConfFile, 'milterpidfile');
        WritePIDFile($$,$PidFile);

        MailScanner::Log::Reset();

        my %my_callbacks =
        (
            'connect' => \&connect_callback,
            'helo' =>    \&helo_callback,
            'envrcpt' => \&envrcpt_callback,
            'header' =>  \&header_callback,
            'eoh' =>     \&eoh_callback,
            'body' =>    \&body_callback,
            'eom' =>     \&eom_callback,
        );
        
        my $conn = 'inet:33333@127.0.0.1';
        $ENV{PMILTER_DISPATCHER} = 'prefork';
        my $milter = Sendmail::PMilter->new();
        $milter->register('mymilter',
                      \%my_callbacks,
                      Sendmail::PMilter::SMFI_CURR_ACTS
                     );
        $milter->setconn($conn);
        $< = $> = getpwnam('postfix');
        $( = $) = getgrnam('mtagroup');
        $milter->main(10,100);
    
        # Should never get here, if we did, it didn't work
        MailScanner::Log::WarnLog("Unable to spawn milter!");
        exit 1
    }
    # Successful if we reach this point
    exit 0;
}

1;
